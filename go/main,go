package main

import (
	"fmt"
	"math/rand"
	"os"
	"time"

	"github.com/gdamore/tcell/v2"
)

type Obstacle struct {
	X        float64
	GapStart int
	GapEnd   int
	Passed   bool
}


type FlappyBird struct {
	screen          tcell.Screen
	width           int
	height          int
	birdX           int
	birdY           float64
	birdVelocity    float64
	birdChars       []rune
	birdFrame       int
	obstacleChar    rune
	obstacleTop     rune
	obstacleBottom  rune
	obstacles       []Obstacle
	gapSize         int
	gravity         float64
	flapPower       float64
	score           int
	gameOver        bool
	lastUpdate      time.Time
	animationCounter int
}


func NewFlappyBird(screen tcell.Screen) *FlappyBird {
	width, height := screen.Size()
	
	fb := &FlappyBird{
		screen:         screen,
		width:          width,
		height:         height,
		birdX:          width / 4,
		birdY:          float64(height / 2),
		birdChars:      []rune{'>', '^', '>'},
		birdFrame:      0,
		obstacleChar:   '║',
		obstacleTop:    '╦',
		obstacleBottom: '╩',
		gapSize:        6,
		gravity:        0.05,
		flapPower:      -0.3,
		lastUpdate:     time.Now(),
	}
	
	fb.ResetGame()
	return fb
}


func (fb *FlappyBird) ResetGame() {
	fb.birdY = float64(fb.height / 2)
	fb.birdVelocity = 0
	fb.obstacles = []Obstacle{}
	fb.NewObstacle()
	fb.score = 0
	fb.gameOver = false
	fb.lastUpdate = time.Now()
	fb.animationCounter = 0
}


func (fb *FlappyBird) NewObstacle() {
	gapStart := rand.Intn(fb.height-fb.gapSize-6) + 3
	
	obstacle := Obstacle{
		X:        float64(fb.width - 1),
		GapStart: gapStart,
		GapEnd:   gapStart + fb.gapSize,
		Passed:   false,
	}
	
	fb.obstacles = append(fb.obstacles, obstacle)
}