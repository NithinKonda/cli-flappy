package main

import (
	"fmt"
	"math/rand"
	"os"
	"time"

	"github.com/gdamore/tcell/v2"
)

type Obstacle struct {
	X        float64
	GapStart int
	GapEnd   int
	Passed   bool
}


type FlappyBird struct {
	screen          tcell.Screen
	width           int
	height          int
	birdX           int
	birdY           float64
	birdVelocity    float64
	birdChars       []rune
	birdFrame       int
	obstacleChar    rune
	obstacleTop     rune
	obstacleBottom  rune
	obstacles       []Obstacle
	gapSize         int
	gravity         float64
	flapPower       float64
	score           int
	gameOver        bool
	lastUpdate      time.Time
	animationCounter int
}


func NewFlappyBird(screen tcell.Screen) *FlappyBird {
	width, height := screen.Size()
	
	fb := &FlappyBird{
		screen:         screen,
		width:          width,
		height:         height,
		birdX:          width / 4,
		birdY:          float64(height / 2),
		birdChars:      []rune{'>', '^', '>'},
		birdFrame:      0,
		obstacleChar:   '║',
		obstacleTop:    '╦',
		obstacleBottom: '╩',
		gapSize:        6,
		gravity:        0.05,
		flapPower:      -0.3,
		lastUpdate:     time.Now(),
	}
	
	fb.ResetGame()
	return fb
}


func (fb *FlappyBird) ResetGame() {
	fb.birdY = float64(fb.height / 2)
	fb.birdVelocity = 0
	fb.obstacles = []Obstacle{}
	fb.NewObstacle()
	fb.score = 0
	fb.gameOver = false
	fb.lastUpdate = time.Now()
	fb.animationCounter = 0
}


func (fb *FlappyBird) NewObstacle() {
	gapStart := rand.Intn(fb.height-fb.gapSize-6) + 3
	
	obstacle := Obstacle{
		X:        float64(fb.width - 1),
		GapStart: gapStart,
		GapEnd:   gapStart + fb.gapSize,
		Passed:   false,
	}
	
	fb.obstacles = append(fb.obstacles, obstacle)
}

func (fb *FlappyBird) UpdateBird(dt float64) {
	fb.birdVelocity += fb.gravity * dt * 10
	fb.birdY += fb.birdVelocity
	
	if fb.animationCounter%5 == 0 {
		fb.birdFrame = (fb.birdFrame + 1) % len(fb.birdChars)
	}
	
	if fb.birdY < 1 {
		fb.birdY = 1
		fb.birdVelocity = 0
	} else if fb.birdY >= float64(fb.height-1) {
		fb.birdY = float64(fb.height - 1)
		fb.gameOver = true
	}
}


func (fb *FlappyBird) UpdateObstacles(dt float64) {
	speed := 15.0 * dt
	
	for i := range fb.obstacles {
		fb.obstacles[i].X -= speed
		
		if !fb.obstacles[i].Passed && fb.obstacles[i].X < float64(fb.birdX) {
			fb.score++
			fb.obstacles[i].Passed = true
		}
		
		if fb.birdX >= int(fb.obstacles[i].X) && 
		   fb.birdX <= int(fb.obstacles[i].X)+1 && 
		   (int(fb.birdY) < fb.obstacles[i].GapStart || int(fb.birdY) >= fb.obstacles[i].GapEnd) {
			fb.gameOver = true
		}
	}
	var newObstacles []Obstacle
	for _, o := range fb.obstacles {
		if o.X > 0 {
			newObstacles = append(newObstacles, o)
		}
	}
	fb.obstacles = newObstacles
	
	if len(fb.obstacles) == 0 || fb.obstacles[len(fb.obstacles)-1].X < float64(fb.width-20) {
		fb.NewObstacle()
	}
}
